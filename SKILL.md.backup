---
name: dify-plugin
description: Guide for creating Dify plugins (Tool, Trigger, Extension, Model, Datasource, Agent Strategy). Use when building integrations for Dify workflows, adding new tools, connecting external services via webhooks, or implementing custom model providers. Supports Python SDK with YAML configurations.
dependencies: python>=3.12, dify_plugin>=0.1.0, httpx, uv
---

# Dify Plugin Development

Build plugins that extend Dify's capabilities through tools, triggers, extensions, models, datasources, and agent strategies.

---

## When to Apply This Skill

Use this Skill when you need to:

- âœ… **Create** a new Dify plugin from scratch
- âœ… **Integrate** external APIs (Mercury, QuickBooks, GitHub, etc.)
- âœ… **Implement** authentication (OAuth2, API Key, Token)
- âœ… **Add** triggers for webhook events
- âœ… **Debug** plugin errors and validation issues
- âœ… **Package** and deploy plugins to Dify platform
- âœ… **Extend** Dify workflows with custom tools or models

**Do NOT use** this Skill for:
- âŒ General Python programming unrelated to Dify
- âŒ Frontend development
- âŒ Dify platform configuration (not plugin development)

---

## Quick Start

### 1. Install Required Tools

```bash
# Install Dify CLI
brew tap langgenius/dify && brew install dify

# Install uv (modern Python package manager)
curl -LsSf https://astral.sh/uv/install.sh | sh
```

### 2. Create Your First Plugin

```bash
# Interactive mode (recommended for beginners)
dify plugin init

# Quick mode (for experienced developers)
dify plugin init --quick --name my-plugin --category tool --language python
```

### 3. Setup Dependencies

```bash
cd my-plugin
uv init --no-readme     # Initialize uv project
uv add dify_plugin      # Add Dify SDK
```

### 4. Package and Deploy

```bash
dify plugin package ./my-plugin
# Upload the .difypkg file to Dify
```

---

## Plugin Types

Choose the right plugin type for your integration:

| Type | Purpose | Use When |
|------|---------|----------|
| **Tool** | Add capabilities to workflows | Integrating APIs (search, database, SaaS) |
| **Trigger** | Start workflows from events | Receiving webhooks (GitHub, Slack, custom) |
| **Extension** | Custom HTTP endpoints | Building APIs, OAuth callbacks |
| **Model** | New AI model providers | Adding LLM/embedding providers |
| **Datasource** | External data connections | Connecting to databases, cloud storage |
| **Agent Strategy** | Custom agent logic | Implementing specialized reasoning |

ðŸ’¡ **Tip**: Start with **Tool** plugins if you're unsure. They're the most common and easiest to implement.

ðŸ“š **Detailed References**: See [references/](references/) folder for type-specific guides.

---

## Development Workflow

Follow this 8-phase process to build reliable plugins:

### ðŸ“ Phase 0: Pre-Planning

**Quick Checklist:**
- [ ] Identify plugin type (Tool/Trigger/Model/etc.)
- [ ] Read target API documentation
- [ ] Check authentication method (OAuth2/API Key)
- [ ] Search for similar official plugins

**Official Plugin Examples**: [references/plugins_reference.md](references/plugins_reference.md)

---

### âœ… Phase 1: Requirements Analysis

**Define:**
1. What problem does this solve?
2. Which service are you integrating?
3. What authentication is needed?
4. What data flow is required? (read/write/events)

---

### ðŸ“‹ Phase 2: Scope Definition

**For Tool Plugins:**
- List 3-7 tools for MVP (e.g., `get_accounts`, `create_charge`)
- Prioritize essential vs. nice-to-have
- Map tool dependencies
- Note API limitations (rate limits, regions)

---

### ðŸ“ Phase 3: Planning & Approval

**Key Files to Plan:**
- `manifest.yaml` - Plugin metadata
- `provider.yaml` - Authentication config
- `provider.py` - OAuth/validation logic
- `tools/*.yaml` - Tool definitions
- `tools/*.py` - Tool implementations

---

### ðŸ”¨ Phase 4: Development

**Core Implementation Steps:**

1. **Build Skeleton**
   ```bash
   mkdir -p my_plugin/{_assets,provider,tools}
   touch my_plugin/{manifest.yaml,main.py}
   ```

2. **Implement Provider** (`provider.py`)
   - `_validate_credentials()` - Check token validity
   - `_oauth_get_authorization_url()` - Generate OAuth URL (if OAuth)
   - `_oauth_get_credentials()` - Exchange code for token (if OAuth)

3. **Implement Tools** (`tools/*.py`)
   - One file per tool
   - Return JSON directly (no LLM calls)
   - Handle errors gracefully

**Code Review Checklist:**
- [ ] No unnecessary LLM calls in tools
- [ ] Use `httpx.HTTPError` (not `RequestException`)
- [ ] No hardcoded URLs or credentials
- [ ] Proper timeout values (30s recommended)

ðŸ“š **Detailed Templates**: See [references/yaml-schemas.md](references/yaml-schemas.md)

---

### ðŸ”‘ Phase 5: Credential Testing

**Steps:**
1. Register developer account with target service
2. Obtain test credentials (sandbox if available)
3. Write diagnostic script to test API directly
4. Test `_validate_credentials()` locally

**Example Diagnostic Script:**
```python
import httpx

def test_api_key(api_key):
    url = "https://api.example.com/v1/test"
    headers = {"Authorization": f"Bearer {api_key}"}
    response = httpx.get(url, headers=headers, timeout=30)
    print(f"Status: {response.status_code}")
    if response.status_code == 200:
        print("âœ… API Key is valid!")
    else:
        print(f"âŒ Error: {response.text}")
```

---

### ðŸ§ª Phase 6: End-to-End Testing

**Testing Pyramid:**

1. **Local Testing** - Mock Dify runtime, test tools independently
2. **Package Testing** - `dify plugin package ./my_plugin`
3. **Upload & Configure** - Test in Dify UI with real credentials
4. **Integration Testing** - Create test workflow, chain multiple tools

**Test Cases:**
- âœ… Normal case: Valid inputs, successful response
- âŒ Error case: Invalid inputs, API errors
- ðŸ” Edge case: Empty results, rate limits, timeouts

---

### ðŸ“š Phase 7: Documentation & Release

**Required Documentation:**
- `README.md` - Overview, features, setup guide
- `CHANGELOG.md` - Version history
- `PRIVACY.md` - Data handling policies (if applicable)

**Version Management** (Semantic Versioning):
- `0.1.0` - Initial release
- `0.2.0` - New feature (backward compatible)
- `0.2.1` - Bug fix
- `1.0.0` - Breaking change

---

### ðŸ”„ Phase 8: Maintenance & Iteration

**Ongoing Tasks:**
- Monitor user feedback
- Fix critical bugs (increment patch version)
- Add new features (increment minor version)
- Update dependencies regularly

---

## Common Pitfalls

### âŒ DON'T

**1. Use LLM in tools for simple formatting**
```python
# âŒ BAD - Wastes tokens and adds latency
yield self.create_text_message(
    self.session.model.summary.invoke(
        text=json.dumps(data),
        instruction="Format this nicely"
    )
)

# âœ… GOOD - Return JSON directly
yield self.create_json_message(data)
```

**2. Use wrong exception types**
```python
# âŒ BAD
except httpx.RequestException as e:  # This doesn't exist!

# âœ… GOOD
except httpx.HTTPError as e:
```

**3. Use invalid tags**

Only these 19 tags are valid:
`search`, `image`, `videos`, `weather`, `finance`, `design`, `travel`, `social`, `news`, `medical`, `productivity`, `education`, `business`, `entertainment`, `utilities`, `agent`, `rag`, `trigger`, `other`

```yaml
# âŒ BAD
tags:
  - banking      # Invalid!
  - payments     # Invalid!

# âœ… GOOD
tags:
  - finance      # Official tag
  - utilities
```

**4. Request unnecessary permissions**
```yaml
# âŒ BAD - Don't request model permission if not using LLM
permission:
  model:
    enabled: true  # Only if actually using LLM!

# âœ… GOOD
permission:
  tool:
    enabled: true
```

### âœ… DO

**1. Return structured data**
```python
result = {
    "id": "123",
    "status": "success",
    "amount": 100.00
}
yield self.create_json_message(result)
```

**2. Handle errors gracefully**
```python
if response.status_code == 401:
    yield self.create_text_message(
        "Authentication failed. Please check your API token."
    )
elif response.status_code == 404:
    yield self.create_text_message(
        f"Resource '{resource_id}' not found."
    )
```

**3. Support multiple environments**
```python
def get_api_url(self, credentials):
    env = credentials.get("environment", "sandbox")
    urls = {
        "sandbox": "https://api-sandbox.example.com",
        "production": "https://api.example.com"
    }
    return urls[env]
```

---

## Debugging Guide

### Error: "permission denied, you need to enable llm access"

**Cause**: Tool is calling `self.session.model.summary.invoke()` but manifest doesn't have model permission.

**Solution**: Remove LLM calls from tools, return JSON directly.

---

### Error: "AttributeError: module 'http
x' has no attribute 'RequestException'"

**Cause**: Using non-existent exception type.

**Solution**: Change to `httpx.HTTPError`:
```python
except httpx.HTTPError as e:
    yield self.create_text_message(f"Network error: {e}")
```

---

### Error: "401 Unauthorized" in production

**Cause**: Using sandbox credentials in production environment.

**Solution**: Add environment selection to provider and use correct credentials for each environment.

---

### Error: "Field validation for 'Tags[X]' failed on the 'plugin_tag' tag"

**Cause**: Using invalid tag in manifest.yaml.

**Solution**: Use only the 19 valid tags (see Common Pitfalls section).

---

### Tool returns empty data

**Cause**: API response structure changed or credentials lack permissions.

**Solution**:
1. Write diagnostic script to test API directly
2. Check API response structure
3. Verify credential scopes/permissions

---

## Best Practices

### ðŸŽ¯ Keep It Focused

- One plugin per API service
- One tool per operation
- 3-7 tools for MVP

### ðŸ” Security First

- Never commit API keys or tokens
- Use OAuth2 when available
- Validate all user inputs
- Use HTTPS for all API calls

### âš¡ Performance Matters

```python
# Set reasonable timeouts
response = httpx.get(url, timeout=30)

# Handle rate limiting
if response.status_code == 429:
    retry_after = response.headers.get("Retry-After")
    yield self.create_text_message(
        f"Rate limit exceeded. Retry after {retry_after}s"
    )
```

### ðŸ“ Code Quality

```python
# Use type hints
def _invoke(self, tool_parameters: dict[str, Any]) -> Generator[ToolInvokeMessage, None, None]:
    """
    Invoke the tool to fetch data.
    
    Args:
        tool_parameters: Dictionary containing request parameters
        
    Returns:
        Generator yielding response messages
    """
    pass
```

### ðŸ“› Naming Conventions

```
Plugin Directory:    mercury_tools_plugin/
Plugin Name:         mercury_tools
Provider Files:      provider/mercury_tools.{yaml,py}
Tool Files:          tools/get_accounts.{yaml,py}
```

---

## Progressive Disclosure System

This Skill uses a three-level information structure:

### Level 1: Core Guide (This File)
- Quick start instructions
- 8-phase workflow overview
- Common pitfalls and debugging
- Best practices summary

### Level 2: Reference Files
- [tool-plugin.md](references/tool-plugin.md) - Tool plugin details
- [trigger-plugin.md](references/trigger-plugin.md) - Trigger plugin details
- [model-plugin.md](references/model-plugin.md) - Model plugin details
- [extension-plugin.md](references/extension-plugin.md) - Extension plugin details
- [yaml-schemas.md](references/yaml-schemas.md) - Complete YAML templates
- [debugging.md](references/debugging.md) - Advanced debugging techniques
- [plugins_reference.md](references/plugins_reference.md) - Official plugin examples

### Level 3: Examples
- Complete plugin implementations in [examples/](examples/) folder
- Real-world use cases and patterns

**ðŸ’¡ Navigation Tip**: Start here â†’ Check references for details â†’ Review examples for patterns

---

## Quick Reference

### Core Files

| File | Purpose | Required |
|------|---------|----------|
| `manifest.yaml` | Plugin metadata and configuration | âœ… Yes |
| `main.py` | Entry point: `plugin = Plugin(DifyPluginEnv())` | âœ… Yes |
| `provider/provider.yaml` | Provider identity and credentials schema | âœ… Yes |
| `provider/provider.py` | Provider validation and OAuth logic | âœ… Yes |
| `tools/*.yaml` | Tool definitions with parameters | âœ… Yes (for Tool plugins) |
| `tools/*.py` | Tool implementations | âœ… Yes (for Tool plugins) |
| `py
